#### 分布式、集群存在的session问题

```
1、存储到客户端cookie
	cookie存在客户端 安全性很难保证
	
2、session复制
	session数据冗余 节点越多浪费越大

3、存在文件服务器或者数据库里面
	大量的IO效率问题

4、缓存数据库
	完全在内存中 速度快 数据结构简单
```

#### 缓存数据库

- 水平切分、垂直切分、读写分离  都是通过破坏一定的业务逻辑来换取性能的
- 减少CPU以及IO读写操作的压力



#### NoSql数据库概述

NoSQL(Not Only SQL) “不仅仅是SQL”,泛指 `非关系的数据库`

NoSQL不依赖业务逻辑方式存储,而以简单的key-value的模式存储。因此大大的增加了

数据库扩展能力

- 不遵循SQL标准
- 不支持ACID（原子性、一致性、隔离性、持久性）
- 远超SQL的性能（就是key,value的形式）

适用场景

- 对数据高并发的读写
- 海里数据的读写
- 对数据高扩展性的

不适用场景

- 需要事务支持
- 需要sql的结构化查询存储,处理复杂的关系,需要即时查询
- 用不着sql的和用了sql也不行的情况，考虑用NoSQL

#### Redis特点

- 数据都在内存中，`支持持久化`，主要用作备份恢复
- 除了支持简单的key-value模式，还支持多种数据结构的存储，比如list、set、hash、zset等
- 一般作为缓存数据库辅助持久化的数据库



#### Redis6-概述和安装

- tar -zxvf redis-6.2.1.tar.gz
- make 编译成C文件
- make install 进行redis安装
- 安装目录：/usr/local/bin
- redis-benchmark：性能测试工具，可以在自己本子运行，看看自己本子性能如何
- redis-check-aof：修复有问题的AOF文件
- redis-check-dump：修复有问题的dump.rdb文件
- redis-sentinel：Redis集群使用
- redis-server：Redis服务器启动命令
- redis-cli：客户端，操作入口



- cp redis.conf /etc/redis.conf 复制配置到/etc文件目录下
- 后台启动设置daemonize no 改成yes
- redis-server /etc/redis.conf 启动redis并指向相关配置文件
- ps -ef | grep redis 查看redis启动信息
- shutdown 进行关闭  
- 适用kill -9 进行进程关闭



#### Redis6-key键操作

- keys* 查看当前库所有key（匹配：keys * 1）
- exists key 判断某个key是否存在
- type key 擦看你的key是什么类型
- del key 删除指定的key数据
- unlink  key 根据value选择非阻塞删除（仅将keys从keyspace元数据中删除，真正的删除会在后续异步操作）
- expire key 10 10秒钟：为给定的key设置过期时间表
- ttl key 查看还有多少秒过期，-1表示永不过期，-2表示已过期
- select 命令切换数据库
- dbsize 查看当前数据库的key的数量
- flushdb 清空当前库
- flushall 通杀所有库



#### Redis6-常用数据类型-String字符串

- String类型是Redis最基本的数据类型，一个Redis中字符串value最多可以是512M
- String类型是二进制安全的。意味着Redis的string可以包含任何数据。比如jpg图片或者序列化对象
- get <key>查询对应键值
- append <key><value>将给定的<value>追加到原值的末尾
- strlen <key>获得值的长度
- setnx <key><value>只有在key不存在时 设置key的值
- incr <key> 将key中存储的数字值增1 只能对数字值操作，如果为空，新增值为1
- decr <key> 将key中存储的数字值减1
- incrby/decrby <key><步长>将key中存储的数字值增减。自定义步长
- 原子性：所谓原子操作是指不会被线程调度机制都打断的操作
- 这种操作一旦开始，就一直运行到结束，中间不会有任何context switch（切换到另一个线程）
- 在单线程中，能够在单条指令中完成的操作都可以认为是“原子操作”，因为中断只能发生于指令质检。
- 在多线程中，不能被其他进程（线程）打断的操作就叫做原子操作。
- Redis单命令的原子性主要得益于Redis的单线程。